/**
 * ArkSwipeDeck å®Œæ•´åŠŸèƒ½æ¼”ç¤º
 *
 * å±•ç¤ºSwipeCardStackç»„ä»¶çš„æ‰€æœ‰åŠŸèƒ½ï¼š
 * - åŸºç¡€æ»‘åŠ¨äº¤äº’
 * - ç¨‹åºåŒ–æ§åˆ¶
 * - åŠ¨æ€é…ç½®
 * - å¤šç§åŠ¨ç”»ç±»å‹
 * - å››æ–¹å‘æ»‘åŠ¨
 * - æ€§èƒ½ç›‘æ§
 *
 * @since 1.0.0
 */

import { SwipeCardStack } from 'arkswipe-deck';
import type {
  CardData,
  CardDataPrimitiveValue,
  SwipeCardStackConfig,
  SwipeCardStackCallbacks,
  SwipeCardStackController,
  SwipeEvent
} from 'arkswipe-deck';
import { SwipeDirection, AnimationType, DEFAULT_SWIPE_CARD_STACK_CONFIG } from 'arkswipe-deck';

/**
 * ç»Ÿè®¡æ•°æ®æ¥å£
 */
interface StatsData {
  readonly likes: number;
  readonly dislikes: number;
  readonly ups: number;
  readonly downs: number;
}

/**
 * ç”¨æˆ·èµ„æ–™æ¥å£
 */
interface UserProfile {
  readonly name: string;
  readonly role: string;
  readonly description: string;
  readonly features: readonly string[];
}

/**
 * é…ç½®æ›´æ–°è¾…åŠ©ç±»
 */
class ConfigHelper {
  /**
   * åˆ›å»ºåŸºç¡€æ¨¡å¼é…ç½®
   */
  static createBasicConfig(): SwipeCardStackConfig {
    const defaultConfig = DEFAULT_SWIPE_CARD_STACK_CONFIG;

    return {
      stack: {
        visibleCount: defaultConfig.stack.visibleCount,
        cardSpacing: defaultConfig.stack.cardSpacing,
        scaleStep: defaultConfig.stack.scaleStep,
        opacityStep: defaultConfig.stack.opacityStep,
        rotationStep: defaultConfig.stack.rotationStep
      },
      swipe: {
        threshold: defaultConfig.swipe.threshold,
        velocityThreshold: defaultConfig.swipe.velocityThreshold,
        allowedDirections: [SwipeDirection.LEFT, SwipeDirection.RIGHT],
        maxRotation: defaultConfig.swipe.maxRotation,
        enableBounce: defaultConfig.swipe.enableBounce
      },
      animation: {
        type: defaultConfig.animation.type,
        duration: defaultConfig.animation.duration,
        spring: {
          velocity: defaultConfig.animation.spring?.velocity ?? 0,
          mass: defaultConfig.animation.spring?.mass ?? 1,
          stiffness: defaultConfig.animation.spring?.stiffness ?? 400,
          damping: defaultConfig.animation.spring?.damping ?? 30
        },
        friction: {
          friction: defaultConfig.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: defaultConfig.enableLoop,
      debug: defaultConfig.debug
    };
  }

  /**
   * åˆ›å»ºç¨‹åºæ§åˆ¶æ¨¡å¼é…ç½®
   */
  static createProgrammaticConfig(): SwipeCardStackConfig {
    const defaultConfig = DEFAULT_SWIPE_CARD_STACK_CONFIG;

    return {
      stack: {
        visibleCount: defaultConfig.stack.visibleCount,
        cardSpacing: defaultConfig.stack.cardSpacing,
        scaleStep: defaultConfig.stack.scaleStep,
        opacityStep: defaultConfig.stack.opacityStep,
        rotationStep: defaultConfig.stack.rotationStep
      },
      swipe: {
        threshold: defaultConfig.swipe.threshold,
        velocityThreshold: defaultConfig.swipe.velocityThreshold,
        allowedDirections: defaultConfig.swipe.allowedDirections,
        maxRotation: defaultConfig.swipe.maxRotation,
        enableBounce: defaultConfig.swipe.enableBounce
      },
      animation: {
        type: AnimationType.SPRING,
        duration: defaultConfig.animation.duration,
        spring: {
          velocity: defaultConfig.animation.spring?.velocity ?? 0,
          mass: defaultConfig.animation.spring?.mass ?? 1,
          stiffness: defaultConfig.animation.spring?.stiffness ?? 400,
          damping: defaultConfig.animation.spring?.damping ?? 30
        },
        friction: {
          friction: defaultConfig.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: defaultConfig.enableLoop,
      debug: defaultConfig.debug
    };
  }

  /**
   * åˆ›å»ºå››å‘æ»‘åŠ¨æ¨¡å¼é…ç½®
   */
  static createFourwayConfig(): SwipeCardStackConfig {
    const defaultConfig = DEFAULT_SWIPE_CARD_STACK_CONFIG;

    return {
      stack: {
        visibleCount: defaultConfig.stack.visibleCount,
        cardSpacing: defaultConfig.stack.cardSpacing,
        scaleStep: defaultConfig.stack.scaleStep,
        opacityStep: defaultConfig.stack.opacityStep,
        rotationStep: defaultConfig.stack.rotationStep
      },
      swipe: {
        threshold: defaultConfig.swipe.threshold,
        velocityThreshold: defaultConfig.swipe.velocityThreshold,
        allowedDirections: [
          SwipeDirection.LEFT,
          SwipeDirection.RIGHT,
          SwipeDirection.UP,
          SwipeDirection.DOWN
        ],
        maxRotation: defaultConfig.swipe.maxRotation,
        enableBounce: defaultConfig.swipe.enableBounce
      },
      animation: {
        type: defaultConfig.animation.type,
        duration: defaultConfig.animation.duration,
        spring: {
          velocity: defaultConfig.animation.spring?.velocity ?? 0,
          mass: defaultConfig.animation.spring?.mass ?? 1,
          stiffness: defaultConfig.animation.spring?.stiffness ?? 400,
          damping: defaultConfig.animation.spring?.damping ?? 30
        },
        friction: {
          friction: defaultConfig.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: defaultConfig.enableLoop,
      debug: defaultConfig.debug
    };
  }

  /**
   * åˆ›å»ºæ€§èƒ½æµ‹è¯•æ¨¡å¼é…ç½®
   */
  static createPerformanceConfig(): SwipeCardStackConfig {
    const defaultConfig = DEFAULT_SWIPE_CARD_STACK_CONFIG;

    return {
      stack: {
        visibleCount: defaultConfig.stack.visibleCount,
        cardSpacing: defaultConfig.stack.cardSpacing,
        scaleStep: defaultConfig.stack.scaleStep,
        opacityStep: defaultConfig.stack.opacityStep,
        rotationStep: defaultConfig.stack.rotationStep
      },
      swipe: {
        threshold: defaultConfig.swipe.threshold,
        velocityThreshold: defaultConfig.swipe.velocityThreshold,
        allowedDirections: defaultConfig.swipe.allowedDirections,
        maxRotation: defaultConfig.swipe.maxRotation,
        enableBounce: defaultConfig.swipe.enableBounce
      },
      animation: {
        type: AnimationType.FRICTION,
        duration: 200,
        spring: {
          velocity: defaultConfig.animation.spring?.velocity ?? 0,
          mass: defaultConfig.animation.spring?.mass ?? 1,
          stiffness: defaultConfig.animation.spring?.stiffness ?? 400,
          damping: defaultConfig.animation.spring?.damping ?? 30
        },
        friction: {
          friction: defaultConfig.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: defaultConfig.enableLoop,
      debug: true
    };
  }
}

@Entry
@Component
struct Index {
  /** å¡ç‰‡æ•°æ® */
  @State private cardList: CardData[] = this.generateCardData();
  /** ç»„ä»¶æ§åˆ¶å™¨ */
  private controller: SwipeCardStackController | null = null;
  /** å½“å‰æ¨¡å¼ */
  @State private currentMode: string = 'basic';
  /** æ“ä½œçŠ¶æ€ */
  @State private currentAction: string = 'é€‰æ‹©æ¼”ç¤ºæ¨¡å¼å¼€å§‹ä½“éªŒ';
  /** ç»Ÿè®¡ä¿¡æ¯ */
  @State private stats: StatsData = this.createInitialStats();
  /** å½“å‰é…ç½® */
  @State private config: SwipeCardStackConfig = DEFAULT_SWIPE_CARD_STACK_CONFIG;
  /** æ˜¾ç¤ºé…ç½®é¢æ¿ */
  @State private showConfig: boolean = false;

  build(): void {
    Column() {
      // é¡¶éƒ¨å¯¼èˆªæ 
      this.buildHeader()

      // æ¨¡å¼é€‰æ‹©å™¨
      this.buildModeSelector()

      // ä¸»è¦æ¼”ç¤ºåŒºåŸŸ
      Stack() {
        this.buildSwipeDemo()
      }
      .width('100%')
      .height(400)
      .margin({ top: 20 })

      // çŠ¶æ€ä¿¡æ¯
      this.buildStatusInfo()

      // æ§åˆ¶æŒ‰é’®åŒºåŸŸ
      if (this.currentMode !== 'basic') {
        this.buildControlButtons()
      }

      // ç»Ÿè®¡é¢æ¿
      this.buildStatsPanel()

      Blank()

      // åº•éƒ¨æ“ä½œåŒº
      this.buildBottomActions()
    }
    .width('100%')
    .height('100%')
    .padding(16)
    .backgroundColor('#F5F7FA')
  }

  /**
   * æ„å»ºé¡¶éƒ¨æ ‡é¢˜
   */
  @Builder
  private buildHeader(): void {
    Row() {
      Column() {
        Text('ArkSwipeDeck')
          .fontSize(28)
          .fontWeight(FontWeight.Bold)
          .fontColor('#1A1A1A')

        Text('å®Œæ•´åŠŸèƒ½æ¼”ç¤º')
          .fontSize(14)
          .fontColor('#666666')
          .margin({ top: 4 })
      }
      .alignItems(HorizontalAlign.Start)

      Blank()

      // é…ç½®æŒ‰é’®
      Button('âš™ï¸')
        .backgroundColor('#007AFF')
        .borderRadius(20)
        .width(40)
        .height(40)
        .onClick((): void => {
          this.showConfig = !this.showConfig;
        })
    }
    .width('100%')
    .margin({ top: 20, bottom: 20 })
  }

  /**
   * æ„å»ºæ¨¡å¼é€‰æ‹©å™¨
   */
  @Builder
  private buildModeSelector(): void {
    Row() {
      this.buildModeButton('basic', 'åŸºç¡€æ¨¡å¼', '#4ECDC4')
      this.buildModeButton('programmatic', 'ç¨‹åºæ§åˆ¶', '#007AFF')
      this.buildModeButton('fourway', 'å››å‘æ»‘åŠ¨', '#FF6B6B')
      this.buildModeButton('performance', 'æ€§èƒ½æµ‹è¯•', '#FFA726')
    }
    .width('100%')
    .justifyContent(FlexAlign.SpaceAround)
  }

  /**
   * æ„å»ºæ¨¡å¼æŒ‰é’®
   */
  @Builder
  private buildModeButton(mode: string, title: string, color: string): void {
    Column() {
      Text(title)
        .fontSize(12)
        .fontColor(this.currentMode === mode ? Color.White : color)
        .fontWeight(this.currentMode === mode ? FontWeight.Bold : FontWeight.Normal)
    }
    .padding({ left: 8, right: 12 })
    .backgroundColor(this.currentMode === mode ? color : 'rgba(0,0,0,0.05)')
    .borderRadius(16)
    .onClick((): void => {
      this.switchMode(mode);
    })
  }

  /**
   * æ„å»ºæ»‘åŠ¨æ¼”ç¤ºåŒºåŸŸ
   */
  @Builder
  private buildSwipeDemo(): void {
    SwipeCardStack({
      cardDataList: this.cardList,
      config: this.config,
      callbacks: this.createCallbacks(),
      cardContentBuilder: (card: CardData, index: number) => {
        this.buildCard(card, index);
      },
      controller: (controller: SwipeCardStackController): void => {
        this.controller = controller;
      }
    })
  }

  /**
   * æ„å»ºå¡ç‰‡å†…å®¹
   */
  @Builder
  private buildCard(card: CardData, index: number): void {
    Column() {
      // å¤´éƒ¨ä¿¡æ¯
      Row() {
                // å¤´åƒ
        Stack() {
          Circle({ width: 50, height: 50 })
            .fill(this.getAvatarColor(index))
          
          Text(this.getCardEmoji(index))
            .fontSize(20)
        }
        Column() {
          Text(this.getCardTitle(card, index))
            .fontSize(18)
            .fontWeight(FontWeight.Bold)
            .fontColor(Color.White)

          Text(this.getCardSubtitle(card, index))
            .fontSize(14)
            .fontColor('#E8E8E8')
            .margin({ top: 2 })
        }
        .alignItems(HorizontalAlign.Start)
        .margin({ left: 12 })

        Blank()

        // æ¨¡å¼æ ‡è¯†
        Text(this.getModeIcon())
          .fontSize(16)
          .fontColor('#E8E8E8')
      }
      .width('100%')
      .padding(20)

      // ä¸»è¦å†…å®¹
      Column() {
        Text(this.getCardDescription(card, index))
          .fontSize(16)
          .fontColor(Color.White)
          .textAlign(TextAlign.Center)
          .maxLines(3)
          .margin({ bottom: 16 })

        // ç‰¹æ€§æ ‡ç­¾
        this.buildFeatureTags(index)
      }
      .layoutWeight(1)
      .justifyContent(FlexAlign.Center)
      .padding({ left: 20, right: 20 })

      // åº•éƒ¨æç¤º
      Row() {
        if (this.currentMode === 'fourway') {
          Text('ğŸ‘â†  â†‘ğŸ‘  â†“âŒ  â†’â¤ï¸')
            .fontSize(12)
            .fontColor('#E8E8E8')
        } else {
          Text('ğŸ‘ å·¦æ»‘æ‹’ç»  |  å³æ»‘å–œæ¬¢ ğŸ‘')
            .fontSize(12)
            .fontColor('#E8E8E8')
        }
      }
      .width('100%')
      .justifyContent(FlexAlign.Center)
      .padding(20)
    }
    .width('100%')
    .height('100%')
    .backgroundColor(this.getCardColor(index))
    .borderRadius(16)
    .shadow({
      radius: 12,
      color: 'rgba(0,0,0,0.15)',
      offsetX: 0,
      offsetY: 6
    })
  }

  /**
   * æ„å»ºç‰¹æ€§æ ‡ç­¾
   */
  @Builder
  private buildFeatureTags(index: number): void {
    Flex({ wrap: FlexWrap.Wrap, justifyContent: FlexAlign.Center }) {
      ForEach(this.getCardFeatures(index), (feature: string) => {
        Text(feature)
          .fontSize(12)
          .fontColor('#E8E8E8')
          .backgroundColor('rgba(255,255,255,0.2)')
          .padding({
            left: 12,
            right: 12,
            top: 6,
            bottom: 6
          })
          .borderRadius(12)
          .margin({ right: 6, bottom: 6 })
      })
    }
  }

  /**
   * æ„å»ºçŠ¶æ€ä¿¡æ¯
   */
  @Builder
  private buildStatusInfo(): void {
    Column() {
      Text(this.currentAction)
        .fontSize(16)
        .fontColor('#333333')
        .textAlign(TextAlign.Center)
        .maxLines(2)
        .lineHeight(22)

      if (this.showConfig) {
        this.buildConfigPanel()
      }
    }
    .width('100%')
    .margin({ top: 16 })
  }

  /**
   * æ„å»ºé…ç½®é¢æ¿
   */
  @Builder
  private buildConfigPanel(): void {
    Column() {
      Text('é…ç½®é¢æ¿')
        .fontSize(14)
        .fontWeight(FontWeight.Bold)
        .fontColor('#333333')
        .margin({ top: 16, bottom: 12 })

      Grid() {
        GridItem() {
          this.buildConfigItem('åŠ¨ç”»ç±»å‹', this.config.animation.type.toString(), (): void => {
            this.switchAnimationType();
          })
        }

        GridItem() {
          this.buildConfigItem('å¯è§å¡ç‰‡', this.config.stack.visibleCount.toString(), (): void => {
            this.adjustVisibleCount();
          })
        }

        GridItem() {
          this.buildConfigItem('å›å¼¹æ•ˆæœ', this.config.swipe.enableBounce ? 'å¼€å¯' : 'å…³é—­', (): void => {
            this.toggleBounce();
          })
        }

        GridItem() {
          this.buildConfigItem('è°ƒè¯•æ¨¡å¼', this.config.debug ? 'å¼€å¯' : 'å…³é—­', (): void => {
            this.toggleDebug();
          })
        }
      }
      .columnsTemplate('1fr 1fr')
      .rowsTemplate('1fr 1fr')
      .columnsGap(8)
      .rowsGap(8)
      .height(100)
    }
    .width('100%')
    .padding(16)
    .backgroundColor('#FFFFFF')
    .borderRadius(12)
    .margin({ top: 12 })
  }

  /**
   * æ„å»ºé…ç½®é¡¹
   */
  @Builder
  private buildConfigItem(label: string, value: string, onClick: () => void): void {
    Column() {
      Text(label)
        .fontSize(12)
        .fontColor('#666666')
      Text(value)
        .fontSize(14)
        .fontWeight(FontWeight.Bold)
        .fontColor('#007AFF')
        .margin({ top: 2 })
    }
    .alignItems(HorizontalAlign.Center)
    .padding(8)
    .backgroundColor('#F8F9FA')
    .borderRadius(8)
    .onClick(onClick)
  }

  /**
   * æ„å»ºæ§åˆ¶æŒ‰é’®
   */
  @Builder
  private buildControlButtons(): void {
    Row() {
      if (this.currentMode === 'programmatic') {
        Button('ğŸ‘ å–œæ¬¢')
          .backgroundColor('#4ECDC4')
          .borderRadius(20)
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.RIGHT);
          })

        Button('ğŸ‘ æ‹’ç»')
          .backgroundColor('#FF6B6B')
          .borderRadius(20)
          .margin({ left: 12 })
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.LEFT);
          })

        Button('ğŸ”„ é‡ç½®')
          .backgroundColor('#FFA726')
          .borderRadius(20)
          .margin({ left: 12 })
          .onClick((): void => {
            this.resetCurrentCard();
          })
      }

      if (this.currentMode === 'fourway') {
        Button('â¬†ï¸')
          .backgroundColor('#4ECDC4')
          .borderRadius(20)
          .width(50)
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.UP);
          })

        Button('â¬‡ï¸')
          .backgroundColor('#FF9500')
          .borderRadius(20)
          .width(50)
          .margin({ left: 12 })
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.DOWN);
          })

        Button('â¬…ï¸')
          .backgroundColor('#FF6B6B')
          .borderRadius(20)
          .width(50)
          .margin({ left: 12 })
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.LEFT);
          })

        Button('â¡ï¸')
          .backgroundColor('#007AFF')
          .borderRadius(20)
          .width(50)
          .margin({ left: 12 })
          .onClick((): void => {
            this.performProgrammaticSwipe(SwipeDirection.RIGHT);
          })
      }
    }
    .width('100%')
    .justifyContent(FlexAlign.Center)
    .margin({ top: 16 })
  }

  /**
   * æ„å»ºç»Ÿè®¡é¢æ¿
   */
  @Builder
  private buildStatsPanel(): void {
    Row() {
      this.buildStatItem('ğŸ‘', 'å–œæ¬¢', this.stats.likes, '#4ECDC4')
      this.buildStatItem('ğŸ‘', 'æ‹’ç»', this.stats.dislikes, '#FF6B6B')

      if (this.currentMode === 'fourway') {
        this.buildStatItem('â¬†ï¸', 'å‘ä¸Š', this.stats.ups, '#4ECDC4')
        this.buildStatItem('â¬‡ï¸', 'å‘ä¸‹', this.stats.downs, '#FF9500')
      }

      this.buildStatItem('ğŸ“±', 'å‰©ä½™', this.cardList.length, '#007AFF')
    }
    .width('100%')
    .justifyContent(FlexAlign.SpaceAround)
    .margin({ top: 20 })
  }

  /**
   * æ„å»ºç»Ÿè®¡é¡¹
   */
  @Builder
  private buildStatItem(icon: string, label: string, value: number, color: string): void {
    Column() {
      Text(icon)
        .fontSize(20)
        .margin({ bottom: 4 })
      Text(value.toString())
        .fontSize(20)
        .fontWeight(FontWeight.Bold)
        .fontColor(color)
      Text(label)
        .fontSize(12)
        .fontColor('#666666')
        .margin({ top: 2 })
    }
    .alignItems(HorizontalAlign.Center)
  }

  /**
   * æ„å»ºåº•éƒ¨æ“ä½œåŒº
   */
  @Builder
  private buildBottomActions(): void {
    Row() {
      Button('ğŸ”„ é‡æ–°å¼€å§‹')
        .backgroundColor('#007AFF')
        .borderRadius(25)
        .height(44)
        .layoutWeight(1)
        .onClick((): void => {
          this.resetDemo();
        })

      Button('ğŸ“Š æ€§èƒ½æµ‹è¯•')
        .backgroundColor('#FFA726')
        .borderRadius(25)
        .height(44)
        .layoutWeight(1)
        .margin({ left: 12 })
        .onClick((): void => {
          this.runPerformanceTest();
        })
    }
    .width('100%')
    .margin({ bottom: 20 })
  }

  // ==============================
  // æ•°æ®å’Œé€»è¾‘æ–¹æ³•
  // ==============================

  /**
   * åˆ›å»ºåˆå§‹ç»Ÿè®¡æ•°æ®
   */
  private createInitialStats(): StatsData {
    const initialStats: StatsData = {
      likes: 0,
      dislikes: 0,
      ups: 0,
      downs: 0
    };

    return initialStats;
  }

  /**
   * ç”Ÿæˆç¤ºä¾‹å¡ç‰‡æ•°æ®
   */
  private generateCardData(): CardData[] {
    const profile1: UserProfile = {
      name: 'å°ç¾',
      role: 'æ‘„å½±å¸ˆ',
      description: 'çƒ­çˆ±æ•æ‰ç”Ÿæ´»ä¸­çš„ç¾å¥½ç¬é—´ ğŸ“¸\nä¸“ä¸šäººåƒå’Œé£æ™¯æ‘„å½±\nåœ¨è¿™é‡Œå¯»æ‰¾æ‹æ‘„ä¼™ä¼´',
      features: ['æ‘„å½±', 'æ—…è¡Œ', 'è‰ºæœ¯', 'å’–å•¡']
    };
    const profile2: UserProfile = {
      name: 'å°é›¨',
      role: 'éŸ³ä¹äºº',
      description: 'ç‹¬ç«‹éŸ³ä¹åˆ¶ä½œäººå’Œæ­Œæ‰‹ ğŸµ\nå–œæ¬¢æ°‘è°£å’Œç”µå­éŸ³ä¹\nå¯»æ‰¾éŸ³ä¹è·¯ä¸Šçš„çŸ¥éŸ³',
      features: ['éŸ³ä¹', 'å‰ä»–', 'åˆ›ä½œ', 'æ¼”å‡º']
    };
    const profile3: UserProfile = {
      name: 'å°å¤',
      role: 'å¥èº«æ•™ç»ƒ',
      description: 'ACSMè®¤è¯ç§äººæ•™ç»ƒ ğŸ’ª\nä¸“æ³¨åŠŸèƒ½æ€§è®­ç»ƒ\nå¸®ä½ æ‰¾åˆ°è¿åŠ¨çš„ä¹è¶£',
      features: ['å¥èº«', 'ç‘œä¼½', 'è¥å…»', 'é©¬æ‹‰æ¾']
    };
    const profile4: UserProfile = {
      name: 'å°ç§‹',
      role: 'ç¾é£Ÿåšä¸»',
      description: 'ç¾é£Ÿæ¢ç´¢è€…å’Œæ–™ç†ç ”ç©¶å®¶ ğŸœ\nåˆ†äº«åœ°é“ç¾é£Ÿå’Œçƒ¹é¥ªæŠ€å·§\nä¸€èµ·å‘ç°å‘³è•¾çš„ç§˜å¯†',
      features: ['ç¾é£Ÿ', 'çƒ¹é¥ª', 'å“é…’', 'æ¢åº—']
    };
    const profile5: UserProfile = {
      name: 'å°å†¬',
      role: 'è®¾è®¡å¸ˆ',
      description: 'UI/UXè®¾è®¡å¸ˆå’Œæ’ç”»å¸ˆ ğŸ¨\nä¸“æ³¨ç”¨æˆ·ä½“éªŒè®¾è®¡\nç”¨è®¾è®¡æ”¹å˜ä¸–ç•Œ',
      features: ['è®¾è®¡', 'æ’ç”»', 'ç”¨æˆ·ä½“éªŒ', 'AI']
    };
    const profile6: UserProfile = {
      name: 'é˜¿å¼º',
      role: 'ç¨‹åºå‘˜',
      description: 'å…¨æ ˆå¼€å‘å·¥ç¨‹å¸ˆ ğŸ’»\nçƒ­çˆ±å¼€æºå’Œæ–°æŠ€æœ¯\nä»£ç æ”¹å˜ç”Ÿæ´»',
      features: ['ç¼–ç¨‹', 'AI', 'å¼€æº', 'æ¸¸æˆ']
    };

    const profiles: UserProfile[] = [profile1, profile2, profile3, profile4, profile5, profile6];

    return profiles.map((profile, index): CardData => {
      const dataMap: Map<string, CardDataPrimitiveValue> = new Map();
      dataMap.set('name', profile.name);
      dataMap.set('role', profile.role);
      dataMap.set('description', profile.description);

      const cardData: CardData = {
        id: `demo_card_${index}_${Date.now()}`,
        index: index,
        visible: true,
        data: dataMap
      };

      return cardData;
    });
  }

  /**
   * åˆ›å»ºäº‹ä»¶å›è°ƒ
   */
  private createCallbacks(): SwipeCardStackCallbacks {
    const callbacks: SwipeCardStackCallbacks = {
      onDragStart: (event: SwipeEvent): void => {
        this.currentAction = 'å¼€å§‹æ‹–æ‹½å¡ç‰‡...';
      },

      onDragUpdate: (event: SwipeEvent): void => {
        const progressPercent: number = Math.round(event.progress * 100);
        if (progressPercent > 20) {
          const directionText: string = this.getDirectionText(event.direction);
          this.currentAction = `${directionText} ${progressPercent}%`;
        }
      },

      onDragEnd: (event: SwipeEvent): void => {
        this.currentAction = 'é‡Šæ”¾æ‹–æ‹½';
      },

      onCardSwiped: (event: SwipeEvent): void => {
        const directionText: string = this.getDirectionText(event.direction);
        const cardName: string = this.getCardName(event.card);

        this.currentAction = `${directionText}äº† ${cardName}`;
        this.updateStats(event.direction);
      },

      onCardBounced: (event: SwipeEvent): void => {
        this.currentAction = 'å¡ç‰‡å·²å›å¼¹åˆ°åŸä½';
      },

      onStackEmpty: (): void => {
        this.currentAction = 'ğŸ‰ æ‰€æœ‰å¡ç‰‡å¤„ç†å®Œæ¯•ï¼';
        setTimeout((): void => {
          this.resetDemo();
        }, 2000);
      },

      onStackUpdate: (visibleCards: CardData[]): void => {
        if (this.config.debug) {
          console.info(`å¯è§å¡ç‰‡æ›´æ–°: ${visibleCards.length}å¼ `);
        }
      }
    };

    return callbacks;
  }

  /**
   * åˆ‡æ¢æ¨¡å¼
   */
  private switchMode(mode: string): void {
    this.currentMode = mode;

    switch (mode) {
      case 'basic':
        this.config = ConfigHelper.createBasicConfig();
        this.currentAction = 'åŸºç¡€æ¨¡å¼ï¼šå·¦å³æ»‘åŠ¨ä½“éªŒ';
        break;

      case 'programmatic':
        this.config = ConfigHelper.createProgrammaticConfig();
        this.currentAction = 'ç¨‹åºæ§åˆ¶ï¼šä½¿ç”¨æŒ‰é’®æ§åˆ¶å¡ç‰‡';
        break;

      case 'fourway':
        this.config = ConfigHelper.createFourwayConfig();
        this.currentAction = 'å››å‘æ»‘åŠ¨ï¼šæ”¯æŒä¸Šä¸‹å·¦å³å…¨æ–¹å‘';
        break;

      case 'performance':
        this.config = ConfigHelper.createPerformanceConfig();
        this.currentAction = 'æ€§èƒ½æ¨¡å¼ï¼šä¼˜åŒ–åŠ¨ç”»å’Œè°ƒè¯•ä¿¡æ¯';
        break;
    }
  }

  /**
   * ç¨‹åºåŒ–æ»‘åŠ¨
   */
  private performProgrammaticSwipe(direction: SwipeDirection): void {
    if (this.controller && this.cardList.length > 0) {
      const topCard: CardData | null = this.controller.getTopCard();
      if (topCard) {
        switch (direction) {
          case SwipeDirection.LEFT:
            this.controller.swipeLeft(true);
            break;
          case SwipeDirection.RIGHT:
            this.controller.swipeRight(true);
            break;
          case SwipeDirection.UP:
            this.controller.swipeUp(true);
            break;
          case SwipeDirection.DOWN:
            this.controller.swipeDown(true);
            break;
        }
      }
    }
  }

  /**
   * é‡ç½®å½“å‰å¡ç‰‡
   */
  private resetCurrentCard(): void {
    if (this.controller) {
      this.controller.resetCard();
      this.currentAction = 'å½“å‰å¡ç‰‡å·²é‡ç½®';
    }
  }

  /**
   * åˆ‡æ¢åŠ¨ç”»ç±»å‹
   */
  private switchAnimationType(): void {
    const types: AnimationType[] = [AnimationType.SPRING, AnimationType.FRICTION, AnimationType.EASE];
    const currentIndex: number = types.indexOf(this.config.animation.type);
    const nextIndex: number = (currentIndex + 1) % types.length;

    const newConfig: SwipeCardStackConfig = {
      stack: {
        visibleCount: this.config.stack.visibleCount,
        cardSpacing: this.config.stack.cardSpacing,
        scaleStep: this.config.stack.scaleStep,
        opacityStep: this.config.stack.opacityStep,
        rotationStep: this.config.stack.rotationStep
      },
      swipe: {
        threshold: this.config.swipe.threshold,
        velocityThreshold: this.config.swipe.velocityThreshold,
        allowedDirections: this.config.swipe.allowedDirections,
        maxRotation: this.config.swipe.maxRotation,
        enableBounce: this.config.swipe.enableBounce
      },
      animation: {
        type: types[nextIndex],
        duration: this.config.animation.duration,
        spring: {
          velocity: this.config.animation.spring?.velocity ?? 0,
          mass: this.config.animation.spring?.mass ?? 1,
          stiffness: this.config.animation.spring?.stiffness ?? 400,
          damping: this.config.animation.spring?.damping ?? 30
        },
        friction: {
          friction: this.config.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: this.config.enableLoop,
      debug: this.config.debug
    };

    this.config = newConfig;
  }

  /**
   * è°ƒæ•´å¯è§å¡ç‰‡æ•°é‡
   */
  private adjustVisibleCount(): void {
    const counts: number[] = [2, 3, 4, 5];
    const currentIndex: number = counts.indexOf(this.config.stack.visibleCount);
    const nextIndex: number = (currentIndex + 1) % counts.length;

    const newConfig: SwipeCardStackConfig = {
      stack: {
        visibleCount: counts[nextIndex],
        cardSpacing: this.config.stack.cardSpacing,
        scaleStep: this.config.stack.scaleStep,
        opacityStep: this.config.stack.opacityStep,
        rotationStep: this.config.stack.rotationStep
      },
      swipe: {
        threshold: this.config.swipe.threshold,
        velocityThreshold: this.config.swipe.velocityThreshold,
        allowedDirections: this.config.swipe.allowedDirections,
        maxRotation: this.config.swipe.maxRotation,
        enableBounce: this.config.swipe.enableBounce
      },
      animation: {
        type: this.config.animation.type,
        duration: this.config.animation.duration,
        spring: {
          velocity: this.config.animation.spring?.velocity ?? 0,
          mass: this.config.animation.spring?.mass ?? 1,
          stiffness: this.config.animation.spring?.stiffness ?? 400,
          damping: this.config.animation.spring?.damping ?? 30
        },
        friction: {
          friction: this.config.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: this.config.enableLoop,
      debug: this.config.debug
    };

    this.config = newConfig;
  }

  /**
   * åˆ‡æ¢å›å¼¹æ•ˆæœ
   */
  private toggleBounce(): void {
    const newConfig: SwipeCardStackConfig = {
      stack: {
        visibleCount: this.config.stack.visibleCount,
        cardSpacing: this.config.stack.cardSpacing,
        scaleStep: this.config.stack.scaleStep,
        opacityStep: this.config.stack.opacityStep,
        rotationStep: this.config.stack.rotationStep
      },
      swipe: {
        threshold: this.config.swipe.threshold,
        velocityThreshold: this.config.swipe.velocityThreshold,
        allowedDirections: this.config.swipe.allowedDirections,
        maxRotation: this.config.swipe.maxRotation,
        enableBounce: !this.config.swipe.enableBounce
      },
      animation: {
        type: this.config.animation.type,
        duration: this.config.animation.duration,
        spring: {
          velocity: this.config.animation.spring?.velocity ?? 0,
          mass: this.config.animation.spring?.mass ?? 1,
          stiffness: this.config.animation.spring?.stiffness ?? 400,
          damping: this.config.animation.spring?.damping ?? 30
        },
        friction: {
          friction: this.config.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: this.config.enableLoop,
      debug: this.config.debug
    };

    this.config = newConfig;
  }

  /**
   * åˆ‡æ¢è°ƒè¯•æ¨¡å¼
   */
  private toggleDebug(): void {
    const newConfig: SwipeCardStackConfig = {
      stack: {
        visibleCount: this.config.stack.visibleCount,
        cardSpacing: this.config.stack.cardSpacing,
        scaleStep: this.config.stack.scaleStep,
        opacityStep: this.config.stack.opacityStep,
        rotationStep: this.config.stack.rotationStep
      },
      swipe: {
        threshold: this.config.swipe.threshold,
        velocityThreshold: this.config.swipe.velocityThreshold,
        allowedDirections: this.config.swipe.allowedDirections,
        maxRotation: this.config.swipe.maxRotation,
        enableBounce: this.config.swipe.enableBounce
      },
      animation: {
        type: this.config.animation.type,
        duration: this.config.animation.duration,
        spring: {
          velocity: this.config.animation.spring?.velocity ?? 0,
          mass: this.config.animation.spring?.mass ?? 1,
          stiffness: this.config.animation.spring?.stiffness ?? 400,
          damping: this.config.animation.spring?.damping ?? 30
        },
        friction: {
          friction: this.config.animation.friction?.friction ?? 0.6
        }
      },
      enableLoop: this.config.enableLoop,
      debug: !this.config.debug
    };

    this.config = newConfig;
  }

  /**
   * è¿è¡Œæ€§èƒ½æµ‹è¯•
   */
  private runPerformanceTest(): void {
    this.currentMode = 'performance';
    this.switchMode('performance');

    // æ¨¡æ‹Ÿå¿«é€Ÿæ“ä½œ
    let count: number = 0;
    const testInterval = setInterval((): void => {
      if (count < 10 && this.cardList.length > 0) {
        const direction: SwipeDirection = count % 2 === 0 ? SwipeDirection.RIGHT : SwipeDirection.LEFT;
        this.performProgrammaticSwipe(direction);
        count++;
      } else {
        clearInterval(testInterval);
        this.currentAction = `æ€§èƒ½æµ‹è¯•å®Œæˆï¼š${count}æ¬¡æ“ä½œ`;
      }
    }, 300);
  }

  /**
   * æ›´æ–°ç»Ÿè®¡
   */
  private updateStats(direction: SwipeDirection): void {
    switch (direction) {
      case SwipeDirection.LEFT:
        const leftStats: StatsData = {
          likes: this.stats.likes,
          dislikes: this.stats.dislikes + 1,
          ups: this.stats.ups,
          downs: this.stats.downs
        };
        this.stats = leftStats;
        break;
      case SwipeDirection.RIGHT:
        const rightStats: StatsData = {
          likes: this.stats.likes + 1,
          dislikes: this.stats.dislikes,
          ups: this.stats.ups,
          downs: this.stats.downs
        };
        this.stats = rightStats;
        break;
      case SwipeDirection.UP:
        const upStats: StatsData = {
          likes: this.stats.likes,
          dislikes: this.stats.dislikes,
          ups: this.stats.ups + 1,
          downs: this.stats.downs
        };
        this.stats = upStats;
        break;
      case SwipeDirection.DOWN:
        const downStats: StatsData = {
          likes: this.stats.likes,
          dislikes: this.stats.dislikes,
          ups: this.stats.ups,
          downs: this.stats.downs + 1
        };
        this.stats = downStats;
        break;
    }
  }

  /**
   * é‡ç½®æ¼”ç¤º
   */
  private resetDemo(): void {
    this.cardList = this.generateCardData();
    this.stats = this.createInitialStats();
    this.currentAction = 'æ¼”ç¤ºå·²é‡ç½®ï¼Œé€‰æ‹©æ¨¡å¼å¼€å§‹ä½“éªŒ';
  }

  // ==============================
  // è¾…åŠ©æ–¹æ³•
  // ==============================

  private getCardTitle(card: CardData, index: number): string {
    return card?.data?.get('name') as string || `ç”¨æˆ· ${index + 1}`;
  }

  private getCardSubtitle(card: CardData, index: number): string {
    return card?.data?.get('role') as string || 'ç¥ç§˜ç”¨æˆ·';
  }

  private getCardDescription(card: CardData, index: number): string {
    return card?.data?.get('description') as string || `è¿™æ˜¯ç¬¬${index + 1}å¼ æ¼”ç¤ºå¡ç‰‡`;
  }

  private getCardFeatures(index: number): string[] {
    const allFeatures: string[][] = [
      ['æ‘„å½±', 'æ—…è¡Œ', 'è‰ºæœ¯', 'å’–å•¡'],
      ['éŸ³ä¹', 'å‰ä»–', 'åˆ›ä½œ', 'æ¼”å‡º'],
      ['å¥èº«', 'ç‘œä¼½', 'è¥å…»', 'é©¬æ‹‰æ¾'],
      ['ç¾é£Ÿ', 'çƒ¹é¥ª', 'å“é…’', 'æ¢åº—'],
      ['è®¾è®¡', 'æ’ç”»', 'ç”¨æˆ·ä½“éªŒ', 'AI'],
      ['ç¼–ç¨‹', 'AI', 'å¼€æº', 'æ¸¸æˆ']
    ];
    return allFeatures[index % allFeatures.length];
  }

  private getCardColor(index: number): string {
    const colors: string[] = [
      'linear-gradient(135deg, #667eea 0%, #764ba2 100%)',
      'linear-gradient(135deg, #f093fb 0%, #f5576c 100%)',
      'linear-gradient(135deg, #4facfe 0%, #00f2fe 100%)',
      'linear-gradient(135deg, #43e97b 0%, #38f9d7 100%)',
      'linear-gradient(135deg, #fa709a 0%, #fee140 100%)',
      'linear-gradient(135deg, #a8edea 0%, #fed6e3 100%)'
    ];
    // ç”±äºArkTSä¸æ”¯æŒCSSæ¸å˜ï¼Œä½¿ç”¨çº¯è‰²æ›¿ä»£
    const solidColors: string[] = ['#667eea', '#f093fb', '#4facfe', '#43e97b', '#fa709a', '#a8edea'];
    return solidColors[index % solidColors.length];
  }

  private getAvatarColor(index: number): string {
    const colors: string[] = ['#FF6B6B', '#4ECDC4', '#45B7D1', '#96CEB4', '#FFEAA7', '#DDA0DD'];
    return colors[index % colors.length];
  }

  private getCardEmoji(index: number): string {
    const emojis: string[] = ['ğŸ“¸', 'ğŸµ', 'ğŸ’ª', 'ğŸœ', 'ğŸ¨', 'ğŸ’»'];
    return emojis[index % emojis.length];
  }

  private getModeIcon(): string {
    switch (this.currentMode) {
      case 'basic':
        return 'ğŸ“±';
      case 'programmatic':
        return 'ğŸ®';
      case 'fourway':
        return 'ğŸ§­';
      case 'performance':
        return 'âš¡';
      default:
        return 'âœ¨';
    }
  }

  private getDirectionText(direction: SwipeDirection): string {
    switch (direction) {
      case SwipeDirection.LEFT:
        return 'æ‹’ç»';
      case SwipeDirection.RIGHT:
        return 'å–œæ¬¢';
      case SwipeDirection.UP:
        return 'è¶…çº§å–œæ¬¢';
      case SwipeDirection.DOWN:
        return 'ä¸æ„Ÿå…´è¶£';
      default:
        return 'æœªçŸ¥æ“ä½œ';
    }
  }

  private getCardName(card: CardData): string {
    if (card.data === undefined || card.data === null) {
      return 'æœªçŸ¥ç”¨æˆ·';
    }
    const name: CardDataPrimitiveValue | undefined = card.data.get('name');
    return (name as string) || 'æœªçŸ¥ç”¨æˆ·';
  }
}